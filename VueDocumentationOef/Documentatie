
Start een Vue instance zo :

var vm = new Vue({
  // options
})

Je can ook componenten aanmaken:

var MyComponent = Vue.extend({
  // extension options
})

Deze componenten kan je initializeren op deze manier :

var myComponentInstance = new MyComponent()

Er dubbele data binding -> Als je 1 van de 2 aanpast past de andere zich sowieso ook aan.

vm.a === data.a -> true
vm.a = 3 -> data.a === 3 -> true + vice versa

$watch -> Met deze functie kan je een variabele "watchen", als deze veranderd kan je een functie oproepen.


lifecycle hooks -> De vue instance gaat door een hele boel initializeringen + Er zullen lifecycle hooks worden uitgevoerd die je zelf kan aanpassen met logica
bv : created, mounted, updated, and destroyed.

TEMPLATE SYNTAX

{{variable}} -> Dubbele moustache zal data tonen die de variabele bevat in de vue instance -> Als het de wijzigenen van de variabele niet mag tonen = v-once

Attributen worden gebruikt met v-bind, niet met de dubbele moustache -> v-bind:id='customid'

Je kan ook basis javascript expressies gebruiken in de html bv : {{number + 1}} & {{oke ? 'yes' : 'no'}}
Er zijn ook filters, die worden aangetoont met | bv : {{message | capitalize}} -> Je kan meerdere filters gebruiken bij 1 variabele + het moet altijd binnen {{}}

DIRECTIVES

Speciale attributen met V- ervoor. bv: v-if -> Sommige van deze directives nemen argumenten aan

Modfigiers: Deze worden aangetoont met een punt bv: .prevent -> event.preventdefault(). <form v-on:submit.prevent='onSubmit'></form> -> de default wordt niet uitgevoerd maar de submit functie wel.

Kleine short hands (deze zal je veel gebruiken dus het wordt afgekort):

v-bind:href="url" == :href="url"

v-on:click="function" == @click="function"

COMPUTED PROPERTIES

Zo weinig mogelijk logica in de html steken. Anders word de tamplate te onduidelijk bv:

<h1>{{ variable ? 'titel1' : 'titel2 '}}</h1>

Vervangen door:

<h1 id="example"> {{ returnTitle }} </h1>

var vm = new Vue({
  el: '#example',
  data: {
    variable: true
  },
  computed: {
    returnTitle: function () {
     	if(this.variable)
     	{
     	 return 'titel1';
     	}
     	else
     	{
     	return 'titel2'
     	}
    }
  }
})

Hier hebben we gebruik gemaakt van een computed propertie. De functie returnTitle() zal gebruikt worden als Getter functie om
de juiste titel te returnen. Als variable veranderd zal de returnTitle terug worden opgeroepen en zal de Titel dus ook veranderen.

Computed vs methods:

Als je het bovenste met een methode had gedaan zal je hetzelfde resultaat krijgen maar er is een verschil:

Een computed propertie wordt opgeroepen als een variabele waar hij afhankelijk van is (een dependencie) wordt gewijzigt.
Als deze niet wordt gewijzigt zal het gewoon de oude waarde returnen die hij heeft gecached -> de functie moet niet worden herhaald.
Als we het met een methode doen zal de functie steeds worden herhaald bij een rerender.

Computed vs Watched properties:

Een watch methode is vaak repeteties en onduidelijk, tegenover een computed propertie.

De computed getter hebben we nu gezien maar er zijn ook computed setters vb:

	computed:{

		title:{

			get: function()
			{
			return title;
			},

			set: function(newVal)
			{
			this.title = newVal;
			}
		}


	}

->vm.title = "niewe titel" = setter
->vm.title = getter

Als het programma iets ingewikkelder is en er moeten methodes worden opgeroepen wanneer er data veranderd is de Watch methode wel aangeraden.
Maar voor de rest moet een computed propertie normaal volstaan.

CLASS + STYLE bindings

Classes en id's zijn attributen -> v-bind bv: <h1 v-bind:id="id"></h1>

We kunnen ook dynamisch klassen toggelen -> v:bind:class="{ active: isActive, text-danger : hasError }"

Het klasse object moet niet inline zijn -> v:bind:class="classObject"
 
We kunnen ook een array van klassen meegeven v-bind:class='[klasse1, klasse2]'

Je kan ook style binden met vue -> v-bind:style="{ color: blue}";

CONDITIONAL RENDERING

vb:

<p v-if = "ok">Yes</p>
<p v-else > No</p>

Dit is voor 1 element. Voor meerdere elementen moet de v-if aan een template worden gekoppelt

<template v-if='ok'>
		
		html elements

</template>

v-else moet direct na v-if komen anders werkt het niet

Je kan ook werken met v-show maar er is een verschil:

v-show wordt sowieso gerenderd in de DOM maar toggled gewoon de display functie van css, met v-if wordt het element conditioneel
in de DOM geladen

Wat is het beste om te gebruiken ?

v-show is trage bij het rederen van de pagina maar sneller bij het toggelen.
v-if is sneller bij het renderen van de pagina maar trager bij het toggelen.

LIST RENDERING

for lus = v-for='item in items'
items is de variabele, item is de alias

v-for="(item, index) in items" -> index stelt de index voor van de item in de items

V-for kan ook door een object -> v-for="value in object"
een extra argument kan ook -> v-for="(key, value) in object" & zelfs v-for="(key, value, index) in object"

key

Het is aangeraden een key mee te geven aan aan je list -> v-for='item in itmes' :key="item.id"
Dit is aangeraden als er nog child components komen of een tijdelijke DOM status.

Array manipulation

push()
pop()
shift()
unshift()
splice()
sort()
reverse()

Bij deze methode wordt de array gwijzigt

functies zoals filter() concat() en slice() zijn functies waarbij er een nieuwe array word aangemaakt en de 
orginele array dus niet wordt aangepast. Dit is redelijk logisch

Caveats. Er zijn 2 zaken die niet herkent worden door vue maar wel logisch lijken
1 : vm.items[index] = newVulue;

Oplossing ->  vm.set(example1.items, index, newValue);
of        ->  example1.items.splice(index,1,newValue);

2 : vm.items.length = newLength;

Oplossing -> example1.items.splice(newLength);

Array fileren

Je kan ook een array filteren de beste manier om dit te doen is met een computed propertie of met een methode.

dan doe je v-for="n in evennumbers" of v-for="n in evenize(numbers)"

methods:{
    evenize:function(list){
      return list.filter(function(number){
        return number % 2 ===0;
      })
    },
  },

  computed:{
    evenNumbers:function()
    {
      return this.numbers.filter(function(number){
        return number % 2 === 0;
      })
    }
  }

